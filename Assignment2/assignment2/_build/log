# dune fmt
# OCAMLPARAM: unset
# Shared cache: enabled-except-user-rules
# Shared cache location:
# C:\Users\patil\AppData\Local\Microsoft\Windows\INetCache\dune\db
# Workspace root: "D:\\COL226\\COL226-Assignments\\Assignment2\\assignment2"
# Auto-detected concurrency: 12
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; instrument_with = []
#  }
$ C:\Users\patil\AppData\Local\opam\my_project\bin\ocamlc.opt.exe -config > C:\Users\patil\AppData\Local\Temp\dune_9afb95_output
$ (cd _build/default && C:\Users\patil\AppData\Local\opam\my_project\bin\ocamlformat.exe --impl bin/main.ml) > _build/default/bin/.formatted/main.ml
> File "bin/main.ml", line 1:
> Warning: Ocamlformat disabled because [--enable-outside-detected-project] is not set and no [.ocamlformat] was found within the project (root: ..\..\..\assignment2)
$ (cd _build/default && C:\Users\patil\AppData\Local\opam\my_project\bin\ocamlformat.exe --impl test/test_assignment2.ml) > _build/default/test/.formatted/test_assignment2.ml
> File "test/test_assignment2.ml", line 1:
> Warning: Ocamlformat disabled because [--enable-outside-detected-project] is not set and no [.ocamlformat] was found within the project (root: ..\..\..\assignment2)
$ (cd _build/default && C:\Users\patil\AppData\Local\opam\my_project\bin\ocamlformat.exe --intf lib/vector.mli) > _build/default/lib/.formatted/vector.mli
$ (cd _build/default && C:\Users\patil\AppData\Local\opam\my_project\bin\ocamlformat.exe --impl lib/vector.ml) > _build/default/lib/.formatted/vector.ml
$ "C:\Program Files\Git\cmd\git.exe" --no-pager diff --no-index --color=always -u --ignore-cr-at-eol _build/default/lib/vector.mli _build/default/lib/.formatted/vector.mli
> diff --git a/_build/default/lib/vector.mli b/_build/default/lib/.formatted/vector.mli
> index 58c12d2..1ab2872 100644
> --- a/_build/default/lib/vector.mli
> +++ b/_build/default/lib/.formatted/vector.mli
> @@ -1,26 +1,28 @@
>  type vector = float list
> +
>  exception DimensionError
>  exception TypeError
> +
>  type types = Bool | Scalar | Vector of int
>  type myBool = T | F
>  type values = B of myBool | S of float | V of vector
>  
> -type expr = T | F
> -| ConstS of float
> -| ConstV of vector
> -| Add of expr * expr
> -| Inv of expr
> -| ScalProd of expr * expr
> -| DotProd of expr * expr
> -| Mag of expr
> -| Angle of expr * expr
> -| IsZero of expr
> -| Cond of expr * expr * expr
> -;;
> +type expr =
> +  | T
> +  | F
> +  | ConstS of float
> +  | ConstV of vector
> +  | Add of expr * expr
> +  | Inv of expr
> +  | ScalProd of expr * expr
> +  | DotProd of expr * expr
> +  | Mag of expr
> +  | Angle of expr * expr
> +  | IsZero of expr
> +  | Cond of expr * expr * expr
>  
>  exception Wrong of expr
>  
> -
>  val create : int -> float -> vector
>  val dim : vector -> int
>  val is_zero : vector -> bool
> warning: in the working copy of 'Assignment2/assignment2/_build/default/lib/.formatted/vector.mli', LF will be replaced by CRLF the next time Git touches it
[1]
$ "C:\Program Files\Git\cmd\git.exe" --no-pager diff --no-index --color=always -u --ignore-cr-at-eol _build/default/lib/vector.ml _build/default/lib/.formatted/vector.ml
> diff --git a/_build/default/lib/vector.ml b/_build/default/lib/.formatted/vector.ml
> index 979e7cd..d7ba7be 100644
> --- a/_build/default/lib/vector.ml
> +++ b/_build/default/lib/.formatted/vector.ml
> @@ -1,237 +1,200 @@
> -type vector = float list;;
> -type types = Bool | Scalar | Vector of int;;
> -type myBool = T | F;;
> -type values = B of myBool | S of float | V of vector;;
> -
> +type vector = float list
> +type types = Bool | Scalar | Vector of int
> +type myBool = T | F
> +type values = B of myBool | S of float | V of vector
>  
>  exception DimensionError
>  exception TypeError
>  
> -
> -type expr = T | F 
> -| ConstS of float
> -| ConstV of vector
> -| Add of expr * expr
> -| Inv of expr
> -| ScalProd of expr * expr
> -| DotProd of expr * expr
> -| Mag of expr
> -| Angle of expr * expr
> -| IsZero of expr
> -| Cond of expr * expr * expr
> -;;
> +type expr =
> +  | T
> +  | F
> +  | ConstS of float
> +  | ConstV of vector
> +  | Add of expr * expr
> +  | Inv of expr
> +  | ScalProd of expr * expr
> +  | DotProd of expr * expr
> +  | Mag of expr
> +  | Angle of expr * expr
> +  | IsZero of expr
> +  | Cond of expr * expr * expr
>  
>  exception Wrong of expr
>  
> -
> -
>  (* Though not used, this function was added for avoiding erros due to precision.*)
>  let _truncate x decimals =
> -  let multiplier = 10.0 ** (float_of_int decimals) in
> -  (floor (x *. multiplier)) /. multiplier;;
> +  let multiplier = 10.0 ** float_of_int decimals in
> +  floor (x *. multiplier) /. multiplier
>  
> -let create (n : int) (x : float) = 
> -  if n < 1 then
> -    raise  DimensionError
> +let create (n : int) (x : float) =
> +  if n < 1 then raise DimensionError
>    else
> -    let rec create_n n acc= 
> -      if n = 0 then acc else create_n (n-1) (x::acc)
> +    let rec create_n n acc =
> +      if n = 0 then acc else create_n (n - 1) (x :: acc)
>      in
>      create_n n []
> -  ;;
>  
>  let dim (v : vector) =
> -   
> -  let rec length u acc = match u with
> -  | [] -> acc
> -  | _x::xs -> length xs (acc + 1)
> +  let rec length u acc =
> +    match u with [] -> acc | _x :: xs -> length xs (acc + 1)
>    in
>    let len = length v 0 in
> -  if len < 1 then
> -    raise DimensionError
> -  else
> -  len
> -  
> -  ;;
> +  if len < 1 then raise DimensionError else len
>  
> -let is_zero (v : vector) = 
> -  if (dim v) < 1 then
> -    raise DimensionError
> +let is_zero (v : vector) =
> +  if dim v < 1 then raise DimensionError
>    else
> -  let rec check_zero v = 
> -    match v with
> -    | [] -> true
> -    | x::xs -> if Float.abs x  < 1e-9 then check_zero xs else false
> -  in
> -  check_zero v;;
> -  
> +    let rec check_zero v =
> +      match v with
> +      | [] -> true
> +      | x :: xs -> if Float.abs x < 1e-9 then check_zero xs else false
> +    in
> +    check_zero v
>  
>  let unit (n : int) (j : int) =
> -  if n < 1 || j < 1 || j > n then
> -    raise DimensionError
> +  if n < 1 || j < 1 || j > n then raise DimensionError
>    else
> -  let rec gen_unit n j acc =
> -    if n = 0 then acc else gen_unit (n-1) j ((if n = j then 1.0 else 0.0)::acc)
> -  in
> -  gen_unit n j [];;
> +    let rec gen_unit n j acc =
> +      if n = 0 then acc
> +      else gen_unit (n - 1) j ((if n = j then 1.0 else 0.0) :: acc)
> +    in
> +    gen_unit n j []
>  
>  (* Here, I have used inbuilt function List.map, I could also do tail recursion here, but occam's razor. *)
> -let scale (x : float) (v : vector) = 
> -  if (dim v) < 1 then
> -    raise DimensionError
> -  else
> -  List.map (fun y -> x *. y) v;;
> -
> +let scale (x : float) (v : vector) =
> +  if dim v < 1 then raise DimensionError else List.map (fun y -> x *. y) v
>  
>  (* In addv, I have added a helper function; to first check the dimension of arguments, if empty list was considered vector, I could have made addv itself recursive. *)
> -let addv (v1 : vector) (v2 : vector) = 
> -  if (dim v1) = (dim v2) then
> +let addv (v1 : vector) (v2 : vector) =
> +  if dim v1 = dim v2 then
>      let rec aux v1 v2 =
> -      match v1, v2 with
> +      match (v1, v2) with
>        | [], [] -> []
> -      | x1::xs1, x2::xs2 -> (x1 +. x2)::(aux xs1 xs2) 
> +      | x1 :: xs1, x2 :: xs2 -> (x1 +. x2) :: aux xs1 xs2
>        | _ -> raise DimensionError
>      in
>      aux v1 v2
> -  else
> -    raise DimensionError;;
> -    
> +  else raise DimensionError
>  
> -let dot_prod (v1 : vector) (v2 : vector) = 
> -  if (dim v1) = (dim v2) then
> +let dot_prod (v1 : vector) (v2 : vector) =
> +  if dim v1 = dim v2 then
>      let rec aux v1 v2 acc =
> -      match v1, v2 with
> +      match (v1, v2) with
>        | [], [] -> acc
> -      | x1::xs1, x2::xs2 -> aux xs1 xs2 (acc +. (x1 *. x2))
> +      | x1 :: xs1, x2 :: xs2 -> aux xs1 xs2 (acc +. (x1 *. x2))
>        | _ -> raise DimensionError
>      in
>      aux v1 v2 0.0
> -  else
> -    raise DimensionError
> +  else raise DimensionError
>  
>  let inv (v : vector) =
> -  if (dim v) < 1 then
> -    raise DimensionError
> -  else 
> -  List.map (fun x -> -.x) v;;
> - 
> -let length (v : vector) = 
> -  if (dim v) < 1 then
> -    raise DimensionError
> -  else
> -  sqrt (dot_prod v v);;
> +  if dim v < 1 then raise DimensionError else List.map (fun x -> -.x) v
> +
> +let length (v : vector) =
> +  if dim v < 1 then raise DimensionError else sqrt (dot_prod v v)
>  
>  (* Because not specified which error should be raised in case of length of any vector is zero, I am raising dimension error. Zero division error could also be raised. *)
>  let angle (v1 : vector) (v2 : vector) =
>    let len_v1 = length v1 in
>    let len_v2 = length v2 in
> -  if len_v1 = 0.0 || len_v2 = 0.0 then
> -    raise DimensionError  
> -  else
> -    acos ((dot_prod v1 v2) /. (len_v1 *. len_v2));;
> -
> -let rec type_of e = match e with
> -     T -> Bool
> -    | F -> Bool
> -    | ConstS _ -> Scalar
> -    | ConstV v -> Vector (dim v)
> -    | Add (e1, e2) -> (match (type_of e1, type_of e2) with
> -        | Scalar, Scalar -> Scalar
> -        | Vector n, Vector m when n = m -> Vector n
> -        | Bool, Bool -> Bool
> -        | _  -> raise TypeError)
> -
> -    | Inv e1 -> (match (type_of e1) with
> -        | Scalar -> Scalar
> -        | Vector n -> Vector n
> -        | Bool -> Bool  
> -    )
> -    
> -    | ScalProd (e1, e2) -> (match (type_of e1, type_of e2) with
> -        | Scalar, Scalar -> Scalar
> -        | Scalar, Vector n -> Vector n
> -        | Bool, Bool -> Bool
> -        | _ -> raise TypeError
> -
> -
> -    )
> -    | DotProd (e1, e2) -> (match (type_of e1, type_of e2) with
> -        | Vector n, Vector m when n = m -> Scalar
> -        | _ -> raise TypeError
> -    )
> -    | Mag e1 -> ( match (type_of e1) with
> -        | Vector _ -> Scalar
> -        | Scalar -> Scalar
> -        | _ -> raise TypeError
> -    )
> -    | Angle (e1, e2) -> (match (type_of e1, type_of e2) with
> -        | Vector n, Vector m when n = m -> Scalar
> -        | _ -> raise TypeError
> -    )
> -    | IsZero e1 -> (match (type_of e1) with
> -        | Bool -> Bool
> -        | Scalar -> Bool
> -        | Vector _ -> Bool
> -    )
> -        
> -        
> -    | Cond (e1, e2, e3) -> (match (type_of e1, type_of e2, type_of e3) with
> -        | Bool, Bool, Bool -> Bool
> -        | Bool, Scalar, Scalar -> Bool
> -        | Bool, Vector n, Vector m when n = m -> Vector n
> -        | _ -> raise TypeError
> -    )
> -    ;;
> -
> -let rec eval e = match e with
> - T -> B T
> -| F -> B F
> -| ConstS sca -> S sca
> -| ConstV vec -> V vec
> -| Add (e1, e2) -> (match (eval e1, eval e2) with
> -    | B T, _ -> B T 
> -    | B F, B T -> B T 
> -    | B F, B F -> B F 
> -    | S sca1, S sca2 -> S (sca1 +. sca2)
> -    | V vec1, V vec2 -> V (addv vec1 vec2)
> -    | _ -> raise TypeError
> -)
> -| Inv e1 -> (match (eval e1) with
> -    | B T -> B F 
> -    | B F -> B T 
> -    | S sca1 -> S (0.0 -. sca1)
> -    | V vec1 -> V (inv vec1)
> -)
> -| ScalProd (e1, e2) -> (match (eval e1, eval e2) with
> -    | B F, _ -> B F
> -    | B T, B F -> B F 
> -    | B T, B T -> B T 
> -    | S sca1, V vec2 -> V (scale sca1 vec2)
> -    | S sca1, S sca2 -> S (sca1 *. sca2)
> -    | _ -> raise TypeError
> -)
> -| DotProd  (e1, e2) -> (match (eval e1, eval e2) with
> -    | V vec1, V vec2 -> S (dot_prod vec1 vec2)
> -    | _ -> raise TypeError
> -)
> -| Mag e1 -> (match (eval e1) with
> -    | S sca -> S (Float.abs sca)
> -    | V vec -> S (length vec)
> -    | _ -> raise TypeError
> -)
> -| Angle (e1, e2) -> (match (eval e1, eval e2) with
> -    | V vec1, V vec2 -> S (angle vec1 vec2)
> -    | _ -> raise TypeError
> -)
> -| IsZero e1 -> (match (eval e1) with
> -    | B F -> B T
> -    | B T -> B F
> -    | S sca1 -> B (if Float.abs sca1 < 1e-9 then T else F)
> -    | V vec -> B (if (is_zero vec) then T else F)
> -)
> -| Cond (e1, e2, e3) -> (match (eval e1) with
> -    | B T -> eval e2 
> -    | B F -> eval e3 
> -    | _ -> raise TypeError
> -)
> -;;
> +  if len_v1 = 0.0 || len_v2 = 0.0 then raise DimensionError
> +  else acos (dot_prod v1 v2 /. (len_v1 *. len_v2))
> +
> +let rec type_of e =
> +  match e with
> +  | T -> Bool
> +  | F -> Bool
> +  | ConstS _ -> Scalar
> +  | ConstV v -> Vector (dim v)
> +  | Add (e1, e2) -> (
> +      match (type_of e1, type_of e2) with
> +      | Scalar, Scalar -> Scalar
> +      | Vector n, Vector m when n = m -> Vector n
> +      | Bool, Bool -> Bool
> +      | _ -> raise TypeError)
> +  | Inv e1 -> (
> +      match type_of e1 with
> +      | Scalar -> Scalar
> +      | Vector n -> Vector n
> +      | Bool -> Bool)
> +  | ScalProd (e1, e2) -> (
> +      match (type_of e1, type_of e2) with
> +      | Scalar, Scalar -> Scalar
> +      | Scalar, Vector n -> Vector n
> +      | Bool, Bool -> Bool
> +      | _ -> raise TypeError)
> +  | DotProd (e1, e2) -> (
> +      match (type_of e1, type_of e2) with
> +      | Vector n, Vector m when n = m -> Scalar
> +      | _ -> raise TypeError)
> +  | Mag e1 -> (
> +      match type_of e1 with
> +      | Vector _ -> Scalar
> +      | Scalar -> Scalar
> +      | _ -> raise TypeError)
> +  | Angle (e1, e2) -> (
> +      match (type_of e1, type_of e2) with
> +      | Vector n, Vector m when n = m -> Scalar
> +      | _ -> raise TypeError)
> +  | IsZero e1 -> (
> +      match type_of e1 with Bool -> Bool | Scalar -> Bool | Vector _ -> Bool)
> +  | Cond (e1, e2, e3) -> (
> +      match (type_of e1, type_of e2, type_of e3) with
> +      | Bool, Bool, Bool -> Bool
> +      | Bool, Scalar, Scalar -> Bool
> +      | Bool, Vector n, Vector m when n = m -> Vector n
> +      | _ -> raise TypeError)
> +
> +let rec eval e =
> +  match e with
> +  | T -> B T
> +  | F -> B F
> +  | ConstS sca -> S sca
> +  | ConstV vec -> V vec
> +  | Add (e1, e2) -> (
> +      match (eval e1, eval e2) with
> +      | B T, _ -> B T
> +      | B F, B T -> B T
> +      | B F, B F -> B F
> +      | S sca1, S sca2 -> S (sca1 +. sca2)
> +      | V vec1, V vec2 -> V (addv vec1 vec2)
> +      | _ -> raise TypeError)
> +  | Inv e1 -> (
> +      match eval e1 with
> +      | B T -> B F
> +      | B F -> B T
> +      | S sca1 -> S (0.0 -. sca1)
> +      | V vec1 -> V (inv vec1))
> +  | ScalProd (e1, e2) -> (
> +      match (eval e1, eval e2) with
> +      | B F, _ -> B F
> +      | B T, B F -> B F
> +      | B T, B T -> B T
> +      | S sca1, V vec2 -> V (scale sca1 vec2)
> +      | S sca1, S sca2 -> S (sca1 *. sca2)
> +      | _ -> raise TypeError)
> +  | DotProd (e1, e2) -> (
> +      match (eval e1, eval e2) with
> +      | V vec1, V vec2 -> S (dot_prod vec1 vec2)
> +      | _ -> raise TypeError)
> +  | Mag e1 -> (
> +      match eval e1 with
> +      | S sca -> S (Float.abs sca)
> +      | V vec -> S (length vec)
> +      | _ -> raise TypeError)
> +  | Angle (e1, e2) -> (
> +      match (eval e1, eval e2) with
> +      | V vec1, V vec2 -> S (angle vec1 vec2)
> +      | _ -> raise TypeError)
> +  | IsZero e1 -> (
> +      match eval e1 with
> +      | B F -> B T
> +      | B T -> B F
> +      | S sca1 -> B (if Float.abs sca1 < 1e-9 then T else F)
> +      | V vec -> B (if is_zero vec then T else F))
> +  | Cond (e1, e2, e3) -> (
> +      match eval e1 with
> +      | B T -> eval e2
> +      | B F -> eval e3
> +      | _ -> raise TypeError)
> warning: in the working copy of 'Assignment2/assignment2/_build/default/lib/.formatted/vector.ml', LF will be replaced by CRLF the next time Git touches it
[1]
