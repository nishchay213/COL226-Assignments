a)
a := 5 + 3 * 2;  // a = 11
b := (10 - 2) / 4; // b = 2
c := 2^3; // c = 8 (Exponentiation)
d := 17 % 5; // d = 2 (Modulus)

b)
x := T && F; // x = false
y := T || F; // y = true
z := !T; // z = false

c)
v1 := 3 [1, 2, 3];
v2 := 3 [4, 5, 6];
sum := v1 +v v2;  // [5, 7, 9]
dot_product := v1 .v v2;  // 1*4 + 2*5 + 3*6 = 32
cross_product := v1 cross_v v2; // [-3, 6, -3]
scaled := 3 scal_v v1;  // [3, 6, 9]
anglevec := v1 angle_v v2 ; // Computes angle between v1 and v2
normalized := norm_v v1; // Normalized vector
magnitude := mag_v v1; // ||v1||

d)
m1 := 2 2 [[1, 2], [3, 4]];
m2 := 2 2 [[5, 6], [7, 8]];
sum := m1 +m m2;  // [[6, 8], [10, 12]]
scaled := 2 scal_m m1;  // [[2, 4], [6, 8]]
product := m1 *m m2;  // Matrix multiplication
determinant := det_m m1; // -2
transpose := tr m1; // [[1, 3], [2, 4]]
inverse := inv_m m1; // [[-2, 1], [1.5, -0.5]]
trace_m1 := trace m1; // 1 + 4 = 5

e)
int x := Input();
int y := Input();
if (x > y) then {
    raise xISgreater;
} else {
    raise yISgreater;
};

f)
i := 0;
while (i < 10) do {
    Print(i);
    i := i + 1;
};

g)
A := 3 3 [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
B := 3 3 [[9, 8, 7], [6, 5, 4], [3, 2, 1]];
C := 3 3 [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
for i := 0 to 2 do {
	for j := 0 to 2 do {
		for k := 0 to 2 do {
			C[i][j] := C[i][j] + A[i][k] * B[k][j];
		};
	};
};

h)
x := 5;
y := 10;
z := 15;
if (x > y) then {
	if (x > z) then {
		raise xISgreater;
	} else {
		raise zISgreater;
	};
}
else {
	if (y > z) then {
		raise yISgreater;
	} else {
		raise zISgreater;
	};
};

i)
int x := Input();
while (x > 0) do {
	Print(x);
	x := x - 1;
};

j)
vec_int 3 v1 := Input();
v2 := 3 [5,6,7];
v3 := v1 +v v2;
Print(v3); 

// type errors
k)
A := 5;
B := 6.2;
C := A + B; // Here type error will occur

l)
A := 3 [4, 5, 6];
B := 3 [8, 9.0, 10]; //this will not parse

m)
A := 3 [4, 5, 6];
B := 4 [8, 9, 10, 15];
C := A +v B; //Type Error as dim different

n)
A := 3 [4, 7, 8];
B := A[2];
Print(B);

o)
A := 2 2 [[4,8], [5,6]];
B := 2 [5,9];
C := A *mv B;
D := B +v C;
